using CareerNavigator.Core.Models.Schema;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using System.Threading;

namespace CareerNavigator.Core.Engines;

/// <summary>
/// Singleton service responsible for managing the in-memory graph Universe.
/// </summary>
/// <remarks>
/// <list type="bullet">
/// <item><description>Loads the <c>universe.json</c> file generated by the Python DataFactory.</description></item>
/// <item><description>Builds optimized lookup structures (<see cref="Dictionary{TKey,TValue}"/> indices) for O(1) performance.</description></item>
/// <item><description>Watches for file changes to support hot-reloading of data without restart.</description></item>
/// </list>
/// </remarks>
public class UniverseProvider : IUniverseProvider, IDisposable
{
    private Universe _universe = null!;
    private readonly string _filePath;
    private readonly FileSystemWatcher? _watcher;
    private readonly ILogger<UniverseProvider> _logger;
    private readonly Lock _lock = new();

    /// <summary>
    /// Initializes a new instance of the <see cref="UniverseProvider"/> class.
    /// </summary>
    /// <param name="env">Hosting environment info (used to locate Data folder).</param>
    /// <param name="logger">Logger instance.</param>
    public UniverseProvider(IWebHostEnvironment env, ILogger<UniverseProvider> logger)
    {
        _logger = logger;

        string fileName = Environment.GetEnvironmentVariable("USE_TEST_UNIVERSE") == "true"
            ? "test_universe.json"
            : "universe.json";

        _filePath = Path.Combine(env.ContentRootPath, "Data", fileName);

        LoadUniverse();

        // Setup File Watcher for Live Updates
        try
        {
            var directory = Path.GetDirectoryName(_filePath);
            if (directory != null && Directory.Exists(directory))
            {
                _watcher = new FileSystemWatcher(directory, fileName);
                _watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size;
                _watcher.Changed += OnFileChanged;
                _watcher.Created += OnFileChanged;
                _watcher.EnableRaisingEvents = true;
                _logger.LogInformation("üåç Universe File Watcher Active on: {Path}", _filePath);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize FileSystemWatcher");
        }
    }

    private void OnFileChanged(object sender, FileSystemEventArgs e)
    {
        // Debounce slightly to avoid read locks during write
        Thread.Sleep(500);
        LoadUniverse();
    }

    private void LoadUniverse()
    {
        lock (_lock)
        {
            if (!File.Exists(_filePath))
            {
                _universe = new Universe();
                _logger.LogWarning("‚ö†Ô∏è Universe file not found at {Path}", _filePath);
                return;
            }

            try
            {
                var json = File.ReadAllText(_filePath);
                var settings = new JsonSerializerSettings
                {
                    ContractResolver = new CamelCasePropertyNamesContractResolver(),
                    NullValueHandling = NullValueHandling.Ignore
                };
                _universe = JsonConvert.DeserializeObject<Universe>(json, settings) ?? new Universe();

                // Build Performance Indices
                _universe.NodeIndex = _universe.Nodes.ToDictionary(n => n.Id, StringComparer.OrdinalIgnoreCase);

                // Calculate Max Phrase Length for N-Gram Parser. Checks for the longest {id} in the Nodes array with empty spaces.
                if (_universe.Nodes.Any())
                {
                    _universe.MaxSkillPhraseLength = _universe.Nodes.Max(n => n.Id.Split(' ').Length);
                }

                // Build AdjacencyList (Bidirectional) - O(E)
                // We manually iterate to ensure A->B also registers B->A in a single pass.

                _universe.AdjacencyList = new Dictionary<string, List<Link>>(StringComparer.OrdinalIgnoreCase);

                foreach (var link in _universe.Links)
                {
                    if (!_universe.AdjacencyList.TryGetValue(link.Source, out var sourceLinks))
                    {
                        sourceLinks = new List<Link>();
                        _universe.AdjacencyList[link.Source] = sourceLinks;
                    }
                    sourceLinks.Add(link);

                    if (!_universe.AdjacencyList.TryGetValue(link.Target, out var targetLinks))
                    {
                        targetLinks = new List<Link>();
                        _universe.AdjacencyList[link.Target] = targetLinks;
                    }
                    targetLinks.Add(link);
                }

                _logger.LogInformation("‚úÖ Universe Loaded: {NodeCount} Nodes, {LinkCount} Links",
                    _universe.Nodes.Count, _universe.Links.Count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Failed to load Universe.json");
                _universe = new Universe();
            }
        }
    }

    /// <summary>
    /// Gets the current in-memory Universe snapshot.
    /// </summary>
    /// <remarks>This operation is thread-safe.</remarks>
    /// <returns>The <see cref="Universe"/> object.</returns>
    public Universe GetUniverse() => _universe;

    /// <summary>
    /// Returns a list of Node IDs directly connected to the specified node.
    /// </summary>
    /// <param name="nodeId">The I of the node to query.</param>
    /// <returns>A list of neighbor IDs. Returns empty if node not found.</returns>
    public List<string> GetNeighbors(string nodeId)
    {
        if (_universe?.AdjacencyList == null) return new List<string>();

        if (_universe.AdjacencyList.TryGetValue(nodeId, out var links))
        {
            return links.Select(l => l.Source.Equals(nodeId, StringComparison.OrdinalIgnoreCase) ? l.Target : l.Source).ToList();
        }

        return new List<string>();
    }

    /// <summary>
    /// Finds the shortest path between two skills using Breadth-First Search (BFS).
    /// </summary>
    /// <param name="startId">The starting skill ID.</param>
    /// <param name="endId">The target skill ID.</param>
    /// <returns>A list of skill IDs representing the path, including start and end. Returns empty if no path exists.</returns>
    public List<string> GetShortestPath(string startId, string endId)
    {
        if (_universe == null) return new List<string>();

        var start = startId.ToLower();
        var end = endId.ToLower();

        if (start == end) return new List<string> { start };

        var queue = new Queue<List<string>>();
        queue.Enqueue(new List<string> { start });

        var visited = new HashSet<string> { start };

        while (queue.Count > 0)
        {
            var path = queue.Dequeue();
            var node = path.Last();

            if (node == end) return path;

            var neighbors = GetNeighbors(node);
            foreach (var neighbor in neighbors)
            {
                var neighborLower = neighbor.ToLower();
                if (!visited.Contains(neighborLower))
                {
                    visited.Add(neighborLower);
                    var newPath = new List<string>(path) { neighborLower };
                    queue.Enqueue(newPath);
                }
            }
        }

        return new List<string>(); // No path found
    }

    /// <summary>
    /// Disposes resources, specifically the file watcher.
    /// </summary>
    public void Dispose()
    {
        _watcher?.Dispose();
    }
}